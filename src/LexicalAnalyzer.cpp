/* Generated by re2c */
#include "LexicalAnalyzer.hpp"
#include "Token.hpp"

#include <iostream>
#include <utility>

using namespace thl;

LexicalAnalyzer::LexicalAnalyzer()
    : m_textPos(std::make_pair(0, 0)) {}

LexicalAnalyzer::~LexicalAnalyzer() {}

void thl::LexicalAnalyzer::setTokenTable(
    std::shared_ptr<TokenTable> lexemTable) {
  m_tokenTable = lexemTable;
}

void thl::LexicalAnalyzer::setConstTable(
    std::shared_ptr<ConstTable> constTable) {
  m_constTable = constTable;
}

void thl::LexicalAnalyzer::setIdentTable(
    std::shared_ptr<IdentTable> identTable) {
  m_identTable = identTable;
}

void thl::LexicalAnalyzer::parse(std::string &line) {
  m_textPos.first++;
  m_textPos.second = 0;
  getTokens(line);
}

void thl::LexicalAnalyzer::getTokens(std::string &line) {
  Token token;

  const char* p = line.c_str();
  const char* q;
  const char* start;
  size_t count = 0;

  for (;;) {
    m_textPos.second++;
    start = p;

    
{
	char yych;
	static const unsigned char yybm[] = {
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 128,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		160, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 128, 128, 128, 128, 128, 128, 
		128, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 128, 128, 128, 128, 192, 
		128, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
	};
	yych = *p;
	if (yybm[0+yych] & 32) {
		goto yy9;
	}
	if (yych <= '.') {
		if (yych <= '%') {
			if (yych <= '\f') {
				if (yych <= 0x00) goto yy2;
				if (yych == '\n') goto yy6;
				goto yy4;
			} else {
				if (yych <= '"') {
					if (yych <= '\r') goto yy8;
					goto yy4;
				} else {
					if (yych <= '#') goto yy12;
					if (yych <= '$') goto yy14;
					goto yy4;
				}
			}
		} else {
			if (yych <= ')') {
				if (yych <= '&') goto yy16;
				if (yych <= '\'') goto yy4;
				if (yych <= '(') goto yy18;
				goto yy20;
			} else {
				if (yych <= '+') {
					if (yych <= '*') goto yy22;
					goto yy24;
				} else {
					if (yych <= ',') goto yy26;
					if (yych <= '-') goto yy28;
					goto yy4;
				}
			}
		}
	} else {
		if (yych <= '>') {
			if (yych <= '9') {
				if (yych <= '/') goto yy30;
				if (yych <= '0') goto yy32;
				if (yych <= '1') goto yy34;
				goto yy4;
			} else {
				if (yych <= ';') {
					if (yych <= ':') goto yy36;
					goto yy4;
				} else {
					if (yych <= '<') goto yy37;
					if (yych <= '=') goto yy4;
					goto yy38;
				}
			}
		} else {
			if (yych <= 'z') {
				if (yych <= '@') goto yy4;
				if (yych <= 'Z') goto yy39;
				if (yych <= '`') goto yy4;
				goto yy39;
			} else {
				if (yych <= '|') {
					if (yych <= '{') goto yy4;
					goto yy42;
				} else {
					if (yych == '~') goto yy44;
					goto yy4;
				}
			}
		}
	}
yy2:
	++p;
	{ 
      tokenPushBack(TokenType::ENDL, -1, m_textPos); 
      break; 
    }
yy4:
	++p;
yy5:
	{
      std::string err = "(" + std::to_string(m_textPos.first) + "," +
                           std::to_string(m_textPos.second) +
                           ") Error: Unknown identifier";
      throw ParseException(err);
      break;
    }
yy6:
	++p;
	{ 
      tokenPushBack(TokenType::ENDL, -1, m_textPos); 
      break; 
    }
yy8:
	yych = *++p;
	if (yych == '\n') goto yy46;
	goto yy5;
yy9:
	yych = *(q = ++p);
	if (yybm[0+yych] & 32) {
		goto yy9;
	}
	if (yych <= '\f') {
		if (yych == '\n') goto yy6;
	} else {
		if (yych <= '\r') goto yy48;
		if (yych == '/') goto yy50;
	}
yy11:
	{ continue; }
yy12:
	++p;
	{ 
      tokenPushBack(TokenType::XOR, -1, m_textPos);
      continue;
    }
yy14:
	++p;
	{
      tokenPushBack(TokenType::NUMBER, (int)m_constTable->size(), m_textPos);
      m_constTable->push_back(-1);
      continue;
    }
yy16:
	++p;
	{ 
      tokenPushBack(TokenType::AND, -1, m_textPos);
      continue;
    }
yy18:
	++p;
	{ 
      tokenPushBack(TokenType::OPEN_BRACKET, -1, m_textPos);
      continue;
    }
yy20:
	++p;
	{ 
      tokenPushBack(TokenType::CLOSE_BRACKET, -1, m_textPos);
      continue;
    }
yy22:
	++p;
	{ 
      tokenPushBack(TokenType::MUL, -1, m_textPos);
      continue;
    }
yy24:
	yych = *++p;
	if (yych == '+') goto yy51;
	if (yych == '>') goto yy53;
	{ 
      tokenPushBack(TokenType::ADD, -1, m_textPos);
      continue;
    }
yy26:
	++p;
	{ 
      tokenPushBack(TokenType::DELIMITER, -1, m_textPos);
      continue;
    }
yy28:
	yych = *++p;
	if (yych == '-') goto yy55;
	if (yych == '>') goto yy57;
	{ 
      tokenPushBack(TokenType::SUB, -1, m_textPos);
      continue;
    }
yy30:
	yych = *++p;
	if (yych == '/') goto yy59;
	{
      tokenPushBack(TokenType::DIF, -1, m_textPos);
      continue;
    }
yy32:
	++p;
	{
      tokenPushBack(TokenType::NUMBER, (int)m_constTable->size(), m_textPos);
      m_constTable->push_back(0);
      continue;
    }
yy34:
	++p;
	{
      tokenPushBack(TokenType::NUMBER, (int)m_constTable->size(), m_textPos);
      m_constTable->push_back(1);
      continue;
    }
yy36:
	yych = *++p;
	if (yych == '=') goto yy62;
	goto yy5;
yy37:
	yych = *++p;
	if (yych == '&') goto yy64;
	if (yych == '|') goto yy66;
	goto yy5;
yy38:
	yych = *++p;
	if (yych == '&') goto yy68;
	if (yych == '|') goto yy70;
	goto yy5;
yy39:
	yych = *++p;
	if (yybm[0+yych] & 64) {
		goto yy39;
	}
	{
      tokenPushBack(TokenType::IDENTIFIER,
        (int)m_identTable->size(), m_textPos);

      std::string s;
      s.assign(start, p - start);
      m_identTable->push_back(s);
      continue;
    }
yy42:
	yych = *++p;
	if (yych == '-') goto yy72;
	if (yych == '=') goto yy74;
	{
      tokenPushBack(TokenType::OR, -1, m_textPos);
      continue;
    }
yy44:
	++p;
	{ 
      tokenPushBack(TokenType::NOT, -1, m_textPos);
      continue;
    }
yy46:
	++p;
	{ 
      tokenPushBack(TokenType::ENDL, -1, m_textPos); 
      break; 
    }
yy48:
	yych = *++p;
	if (yych == '\n') goto yy46;
yy49:
	p = q;
	goto yy11;
yy50:
	yych = *++p;
	if (yych == '/') goto yy59;
	goto yy49;
yy51:
	++p;
	{ 
      tokenPushBack(TokenType::INCREMENT, -1, m_textPos);
      continue;
    }
yy53:
	++p;
	{ 
      tokenPushBack(TokenType::IMPLB, -1, m_textPos);
      continue;
    }
yy55:
	++p;
	{ 
      tokenPushBack(TokenType::DECREMENT, -1, m_textPos);
      continue;
    }
yy57:
	++p;
	{ 
      tokenPushBack(TokenType::IMPL, -1, m_textPos);
      continue;
    }
yy59:
	yych = *++p;
	if (yybm[0+yych] & 128) {
		goto yy59;
	}
	{ break; }
yy62:
	++p;
	{ 
      tokenPushBack(TokenType::ASSIGMENT, -1, m_textPos);
      continue;
    }
yy64:
	++p;
	{ 
      tokenPushBack(TokenType::LEFT_AND, -1, m_textPos);
      continue;
    }
yy66:
	++p;
	{ 
      tokenPushBack(TokenType::LEFT_OR, -1, m_textPos);
      continue;
    }
yy68:
	++p;
	{ 
      tokenPushBack(TokenType::RIGHT_AND, -1, m_textPos);
      continue;
    }
yy70:
	++p;
	{ 
      tokenPushBack(TokenType::RIGHT_OR, -1, m_textPos);
      continue;
    }
yy72:
	++p;
	{ 
      tokenPushBack(TokenType::LIMPL, -1, m_textPos);
      continue;
    }
yy74:
	++p;
	{ 
      tokenPushBack(TokenType::IMPLM, -1, m_textPos);
      continue;
    }
}

  }
}
